<html>
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<!-- <link  href="cropperjs-master/src/css/cropper.css" rel="stylesheet"> -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.7/cropper.css" integrity="sha512-AuLN6bHjJzqZ+Iw48+GdQPp5uKBdPX6+zWV37ju9zw7XIrevIX01RsLtpTU/zCoQcKrQRPe/EpwDpZiv7OUYMA==" crossorigin="anonymous" />
	<!-- <script src="cropperjs-master/src/js/cropper.js" type="module"></script> -->
	<!-- <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.7/cropper.js"></script> -->
	<script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.7/cropper.js" integrity="sha512-giNJUOlLO0dY67uM6egCyoEHV/pBZ048SNOoPH4d6zJNnPcrRkZcxpo3gsNnsy+MI8hjKk/NRAOTFVE/u0HtCQ==" crossorigin="anonymous"></script>
	<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css" integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
	<script src="https://code.jquery.com/jquery-3.5.1.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
	<script src="https://code.jquery.com/ui/1.12.1/jquery-ui.min.js" integrity="sha256-VazP97ZCwtekAsvgPBSUwPFKdrwD3unUfSGVYrahUqU=" crossorigin="anonymous"></script>
	<script src="jquery.ui.touch-punch.min.js"></script>
	<style type="text/css">

		/* Ensure the size of the image fit the container perfectly */
		img {
		  display: block;

		  /* This rule is very important, please don't ignore this */
		  max-width: 100%;
		}
 
	  .puzzle-piece{
	  	/*box-shadow:0px 0px 0px 1px #f00;*/
	  } 

	  .puzzle-piece:after
	  {
			box-shadow: 0px 0px 0px 1px #000000;
			content: '';
			display: block;
			height: 100%;
			position: absolute;
			top: 0;
			width: 100%;
	  }
	  .puzzle-piece.clicked:after { 
	  /* this selector is more specific, so it takes precedence over the other :after */
	      /*box-shadow: 6px 6px 10px 0 #000000;*/
	      box-shadow: 8px 8px 15px 0 rgba(0, 0, 0, 0.5), 0px 0px 4px 0px  #000000;
	  }
	  .puzzle-piece.correct:after { 
	  /* this selector is more specific, so it takes precedence over the other :after */
	      /*box-shadow: 6px 6px 10px 0 #000000;*/
	      box-shadow: 0px 0px 2px 4px rgba(50, 255, 50, 1);
	  }
	  .puzzle-piece.finished:after { 
	  /* this selector is more specific, so it takes precedence over the other :after */
	      /*box-shadow: 6px 6px 10px 0 #000000;*/
	      box-shadow: none;
	  }

  	#puzzle_container{
			display: flex; 
			flex-wrap: wrap;
		}
		#puzzle_container.finished{
	    box-shadow: 0px 0px 2px 4px rgba(50, 255, 50, 1);
			
		}  
	</style>
</head>
<body>
	<div style="visibility: hidden; position: absolute;">
	  <img src="" crossorigin="anonymous" id="target"> 
	</div>
	<div>
	</div>
	<div class="container">
		<h1 class="text-center">Puzzle game</h1>
		<div class="mx-auto mt-4" id="puzzle_container"></div>
	</div>
	<div id="puzzle_piece_template" class="puzzle-piece" style="display: none" >
		
	</div>
</body>
	<script type="text/javascript">
		let newImage;
    let substitute;
    let solutionFound = false;
    let timePanel;
    let fadeScreen;
    let timeCounter = 0;

    target.src = "shoe.webp";

		const cropper = new Cropper(target, {
		  // aspectRatio: 16 / 9, // this affects the cropping parameters, don't enable it
		  crop(event) {

		  },
		  ready() {
		    let imageData = this.cropper.getImageData();

		    // set puzzle container to the aspect ratio of the image
/*		    let aspectRatioInverse = imageData.height / imageData.width;
		    aspectRatioInverse = Math.round(aspectRatioInverse * 100) / 100;
		    puzzle_container.style.width = "100%";
		    puzzle_container.style.paddingBottom = aspectRatioInverse * 100 + "%";*/
		    puzzle_container.style.width = "50vw";
		    puzzle_container.style.height = puzzle_container.offsetWidth / imageData.aspectRatio + "px";
		    let counter = 0;
     		for(let j = 1; j <= 2; j++){
			     for(let i = 1; i <= 3; i++){
							// set  crop size 
							this.cropper.setData({x: (i-1) * imageData.naturalWidth / 3, y:(j-1) * imageData.naturalHeight / 2, width: (imageData.naturalWidth / 3), height: (imageData.naturalHeight / 2) })

							// crop image
							let newImageCanvas = this.cropper.getCroppedCanvas({height: puzzle_container.offsetHeight / 2});
							// constraint piece size

							// show new image
							let puzzle_piece = puzzle_piece_template.cloneNode();
							puzzle_container.appendChild(puzzle_piece)
							puzzle_piece.id = '';
							puzzle_piece.style.display = "block"
							puzzle_piece.addEventListener("mousedown", ()=>{
								$(puzzle_piece).addClass('clicked');
								// alert();
							});
							puzzle_piece.addEventListener("mouseup", ()=>{
								$(puzzle_piece).removeClass('clicked');
							});
							puzzle_piece.appendChild(newImageCanvas);


							// assign the correct position to each piece
							$(puzzle_piece).attr("order-num", counter);
							console.log(puzzle_piece);

							// add dragging ability
							makeDraggable(puzzle_piece);




							this.cropper.reset();
			     		counter++;


		     		}
		    }
			  // shuffle puzzle
				$(function () {
					var parent = $(puzzle_container);
					var divs = parent.children();
					while (divs.length) {
						parent.append(divs.splice(Math.floor(Math.random() * divs.length), 1)[0]);
					}
				});

				// start counting time
				timeCounter = new Date();

		   },
		});

		let splitImage = function (){

		}

		let makeDraggable = function (puzzle_piece){

			$(puzzle_piece).draggable({ 
				containment: "parent", 
				revert: "invalid",
				revertDuration: 120,
			  classes: {
			    "ui-draggable": "highlight"
			  },
			  // opacity: 0.65,
				stack: ".puzzle-piece",
				start: function() {
				},
				drag: function() {
				},
				stop: function() {
					$(this).removeClass('clicked');

				},
				create: function( event, ui ) {

				}
			});
			$(puzzle_piece).draggable("enable");
			$(puzzle_piece).droppable({
				classes: {
			    "ui-droppable-hover": "highlight"
			  },
				greedy: true,
				drop: function( event, ui ) {

					// swap positiuons of dragged  and target pieces
					let draggedPiecePrev = ui.draggable.prev();
					ui.draggable.insertBefore($(this));
					if(draggedPiecePrev.length == 0){
						$(this).prependTo($(this).parent());
					}
					else{
						$(this).insertAfter(draggedPiecePrev);
					}
					ui.draggable.css("top", 0);
					ui.draggable.css("left", 0);

					// check if this piece position is correct
							console.log(ui.draggable.attr("order-num"));
							console.log($(puzzle_container).children().index(ui.draggable));
					if(ui.draggable.attr("order-num") == $(puzzle_container).children().index(ui.draggable)){
							ui.draggable.addClass('correct');
					}
					else{
							ui.draggable.removeClass('correct');

					}
					if($(this).attr("order-num") == $(puzzle_container).children().index($(this))){
						$(this).addClass('correct');
					}
					else{
						$(this).removeClass('correct');
					}

					// check if solution is correct
					solutionFound = true;
					$(puzzle_container).children().each((index, item)=>{
							// console.log(item);
						// console.log($(puzzle_container).children().index(item));
						// console.log(item.correctPosition);
						if($(puzzle_container).children().index(item) == $(item).attr("order-num"))
						{
							return true;	
						}
						else{
							solutionFound = false;
							return false;
						}
					});
					if(solutionFound){
						// make all pieces glow
						$(puzzle_container).children().each((index, item)=>{
							$(item).addClass('finished');

						});
						$(puzzle_container).addClass('finished');
						
						timeCounter = new Date() - timeCounter;
						timeCounter = timeCounter / 1000;
						// show time. lock puzzle
						// timePanel.show();
						setTimeout(()=>{alert("Puzzle finished in " + timeCounter + "  seconds");}, 100);
						
					}
				}
			});
		}


	</script>
</html>